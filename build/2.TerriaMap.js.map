{"version":3,"sources":["webpack:///2.TerriaMap.js","webpack:///./node_modules/terriajs/lib/ReactViews/Map/Navigation/augmented_virtuality_tool.scss?5228","webpack:///./node_modules/terriajs/lib/Models/AugmentedVirtuality.js","webpack:///./node_modules/terriajs/lib/ReactViews/Map/Navigation/AugmentedVirtualityTool.jsx"],"names":["webpackJsonp","2268","module","exports","2269","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_defined","_defined2","_defaultValue","_defaultValue2","_knockout","_knockout2","_Math","_Math2","_Matrix","_Matrix2","_Cartesian","_Cartesian2","_EllipsoidTerrainProvider","_EllipsoidTerrainProvider2","_sampleTerrainMostDetailed","_sampleTerrainMostDetailed2","AugmentedVirtuality","terria","that","this","_terria","_eventLoopState","_manualAlignment","_maximumUpdatesPerSecond","DEFAULT_MAXIMUM_UPDATES_PER_SECOND","_orientationUpdated","_alpha","_beta","_gamma","_realignAlpha","_realignHeading","_hoverLevel","PRESET_HEIGHTS","length","window","addEventListener","event","_storeOrientation","track","defineProperty","get","_eventLoopRunning","set","enable","resetAlignment","enabled","_startEventLoop","_getManualAlignment","startEnd","_setManualAlignment","maximumUpdatesPerSecond","MINIMUM_HOVER_HEIGHT","prototype","toggleEnabled","toggleManualAlignment","manualAlignment","toggleHoverHeight","hover","height","position","flyTo","flyToHeight","surfaceHeight","newPosition","fromRadians","longitude","latitude","pose","_getCurrentOrientation","destination","camera","setView","currentViewer","notifyRepaintRequired","cesium","viewer","positionCartographic","clone","scene","terrainProvider","then","updatedPosition","moveTo","maximumHeight","moveToLocation","hoverHeight","viewerHeight","cameraPosition","undefined","toDegrees","heading","intervalId","intervalMs","id","setInterval","_updateOrientation","clearInterval","alpha","beta","gamma","screenOrientation","_getCurrentScreenOrientation","_lastScreenOrientation","realignAlpha","realignHeading","_computeTerriaOrientation","rotation","IDENTITY","rotationIncrement","fromRotationZ","toRadians","multiply","fromRotationX","fromRotationY","r10","COLUMN1ROW0","r11","COLUMN1ROW1","r02","COLUMN0ROW2","r12","COLUMN1ROW2","r22","COLUMN2ROW2","Math","atan2","roll","pitch","sqrt","orientation","screen","angle","808","_react","_react2","_createReactClass","_createReactClass2","_propTypes","_propTypes2","_ObserveModelMixin","_ObserveModelMixin2","_augmented_virtuality_tool","_augmented_virtuality_tool2","_Icon","_Icon2","_ViewerMode","_ViewerMode2","_AugmentedVirtuality","_AugmentedVirtuality2","AugmentedVirtualityTool","displayName","mixins","propTypes","object","isRequired","viewState","experimentalWarning","bool","getInitialState","augmentedVirtuality","props","experimentalWarningShown","realignHelpShown","resetRealignHelpShown","handleClickAVTool","state","setState","notifications","push","title","message","confirmText","handleClickRealign","handleClickResetRealign","handleClickHover","render","toggleImage","GLYPHS","arOff","toggleStyle","btn","arOn","btnPrimary","realignment","realignmentStyle","btnBlink","hoverLevel","hoverImage","arHover0","arHover1","arHover2","viewerMode","Leaflet","createElement","className","augmentedVirtualityTool","type","onClick","glyph","key","manualAlignmentSet","arRealign","arResetAlignment"],"mappings":"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","file":"2.TerriaMap.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 2268:\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\nmodule.exports = {\"btn\":\"tjs-augmented_virtuality_tool__btn tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-primary\":\"tjs-augmented_virtuality_tool__btn-primary tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btnPrimary\":\"tjs-augmented_virtuality_tool__btn-primary tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-blink\":\"tjs-augmented_virtuality_tool__btn-blink tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btnBlink\":\"tjs-augmented_virtuality_tool__btn-blink tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-primary--hover\":\"tjs-augmented_virtuality_tool__btn-primary--hover\",\"btnPrimaryHover\":\"tjs-augmented_virtuality_tool__btn-primary--hover\",\"blinker\":\"tjs-augmented_virtuality_tool__blinker\",\"toolButton\":\"tjs-augmented_virtuality_tool__toolButton\",\"augmentedVirtualityTool\":\"tjs-augmented_virtuality_tool__augmentedVirtualityTool tjs-tool_button__toolButton\"};\n\n/***/ }),\n\n/***/ 2269:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _defined = __webpack_require__(0);\n\nvar _defined2 = _interopRequireDefault(_defined);\n\nvar _defaultValue = __webpack_require__(1);\n\nvar _defaultValue2 = _interopRequireDefault(_defaultValue);\n\nvar _knockout = __webpack_require__(13);\n\nvar _knockout2 = _interopRequireDefault(_knockout);\n\nvar _Math = __webpack_require__(9);\n\nvar _Math2 = _interopRequireDefault(_Math);\n\nvar _Matrix = __webpack_require__(40);\n\nvar _Matrix2 = _interopRequireDefault(_Matrix);\n\nvar _Cartesian = __webpack_require__(10);\n\nvar _Cartesian2 = _interopRequireDefault(_Cartesian);\n\nvar _EllipsoidTerrainProvider = __webpack_require__(435);\n\nvar _EllipsoidTerrainProvider2 = _interopRequireDefault(_EllipsoidTerrainProvider);\n\nvar _sampleTerrainMostDetailed = __webpack_require__(801);\n\nvar _sampleTerrainMostDetailed2 = _interopRequireDefault(_sampleTerrainMostDetailed);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Manages state for Augmented Virtuality mode.\n *\n * This mode uses the devices orientation sensors to change the viewers viewport to match the change in orientation.\n *\n * Term Augmented Virtuality:\n * \"The use of real-world sensor information (e.g., gyroscopes) to control a virtual environment is an additional form\n * of augmented virtuality, in which external inputs provide context for the virtual view.\"\n * {@link https://en.wikipedia.org/wiki/Mixed_reality}\n *\n * @alias AugmentedVirtuality\n * @constructor\n */\nvar AugmentedVirtuality = function AugmentedVirtuality(terria) {\n    var that = this;\n\n    this._terria = terria;\n\n    // Note: We create a persistant object and define a transient property, since knockout needs a persistant variable\n    //       to track, but for state we want a 'maybe' intervalId.\n    this._eventLoopState = {};\n\n    this._manualAlignment = false;\n\n    this._maximumUpdatesPerSecond = AugmentedVirtuality.DEFAULT_MAXIMUM_UPDATES_PER_SECOND;\n\n    this._orientationUpdated = false;\n    this._alpha = 0;\n    this._beta = 0;\n    this._gamma = 0;\n    this._realignAlpha = 0;\n    this._realignHeading = 0;\n\n    // Set the default height to be the last height so that when we first toggle (and increment) we cycle and go to the first height.\n    this._hoverLevel = AugmentedVirtuality.PRESET_HEIGHTS.length - 1;\n\n    // Always run the device orientation event, this way as soon as we enable we know where we are and set the\n    // orientation rather then having to wait for the next update.\n    // The following is disabled because chrome does not currently support deviceorientationabsolute correctly:\n    // if ('ondeviceorientationabsolute' in window)\n    // {\n    //     window.addEventListener('deviceorientationabsolute', function(event) {that._orientationUpdate(event);} );\n    // }\n    // else\n    if ('ondeviceorientation' in window) {\n        window.addEventListener('deviceorientation', function (event) {\n            that._storeOrientation(event);\n        });\n    }\n\n    // Make the variables used by the object properties knockout observable so that changes in the state notify the UI\n    // and cause a UI update. Note: These are all of the variables used just by the getters (not the setters), since\n    // these unqiquely define what the current state is and are the only things that can effect/cause the state to change\n    // (note: _eventLoopState is hidden behind ._eventLoopRunning() ).\n    _knockout2.default.track(this, ['_eventLoopState', '_manualAlignment', '_maximumUpdatesPerSecond', '_realignAlpha', '_realignHeading', '_hoverLevel']);\n\n    // Note: The following properties are defined as knockout properties so that they can be used to trigger updates on the UI.\n    /**\n     * Gets or sets whether Augmented Virtuality mode is currently enabled (true) or not (false).\n     *\n     * Note: If {@link AugmentedVirtuality#manualAlignment} is enabled and the state is changed it will be disabled.\n     *\n     * @memberOf AugmentedVirtuality.prototype\n     * @member {Boolean} enabled\n     */\n    _knockout2.default.defineProperty(this, 'enabled', {\n        get: function get() {\n            return this._eventLoopRunning() || this._manualAlignment;\n        },\n        set: function set(enable) {\n            if (enable !== true) {\n                enable = false;\n\n                this.resetAlignment();\n            }\n\n            if (enable !== this.enabled) {\n                // If we are changing the enabled state then disable manual alignment.\n                // We only do this if we are changing the enabled state so that the client can repeatedly call the\n                // setting without having any effect if they aren't changing the enabled state, but so that every time\n                // that the state is changed that the manual alignment is turned back off initally.\n                this._manualAlignment = false;\n\n                this._startEventLoop(enable);\n            }\n        }\n    });\n\n    /**\n     * Gets or sets whether manual realignment mode is currently enabled (true) or not (false).\n     *\n     * @memberOf AugmentedVirtuality.prototype\n     * @member {Boolean} manualAlignment\n     */\n    _knockout2.default.defineProperty(this, 'manualAlignment', {\n        get: function get() {\n            return this._getManualAlignment();\n        },\n        set: function set(startEnd) {\n            this._setManualAlignment(startEnd);\n        }\n    });\n\n    /**\n     * Gets whether a manual realignment has been specified (true) or not (false).\n     *\n     * @memberOf AugmentedVirtuality.prototype\n     * @member {Boolean} manualAlignmentSet\n     */\n    _knockout2.default.defineProperty(this, 'manualAlignmentSet', {\n        get: function get() {\n            return this._realignAlpha !== 0.0 || this._realignHeading !== 0.0;\n        }\n    });\n\n    /**\n     * Gets the index of the current hover level.\n     *\n     * Use <code>AugmentedVirtuality.PRESET_HEIGHTS.length</code> to find the total avaliable levels.\n     *\n     * @memberOf AugmentedVirtuality.prototype\n     * @member {int} hoverLevel\n     */\n    _knockout2.default.defineProperty(this, 'hoverLevel', {\n        get: function get() {\n            return this._hoverLevel;\n        }\n    });\n\n    /**\n     * Gets or sets the the maximum number of times that the camera orientation will be updated per second. This is\n     * the number of camera orientation updates per seconds is capped to (explicitly the number of times the\n     * orientation is updated per second might be less but it won't be more then this number). We want the number of\n     * times that the orientation is updated capped so that we don't consume to much battery life updating to\n     * frequently, but responsiveness is still acceptable.\n     *\n     * @memberOf AugmentedVirtuality.prototype\n     * @member {Float} maximumUpdatesPerSecond\n     */\n    _knockout2.default.defineProperty(this, 'maximumUpdatesPerSecond', {\n        get: function get() {\n            return this._maximumUpdatesPerSecond;\n        },\n        set: function set(maximumUpdatesPerSecond) {\n            this._maximumUpdatesPerSecond = maximumUpdatesPerSecond;\n\n            // If we are currently enabled reset to update the timing interval used.\n            if (this._eventLoopRunning()) {\n                this._startEventLoop(false);\n                this._startEventLoop(true);\n            }\n        }\n    });\n\n    this.enabled = false;\n};\n\n/**\n * Gets the the maximum number of times that the camera orientation will be updated per second by default. This is the\n * number of camera orientation updates per seconds is capped to by default (explicitly the number of times the\n * orientation is updated per second might be less but it won't be more then this number). We want the number of times\n * that the orientation is updated capped so that we don't consume to much battery life updating to frequently, but\n * responsiveness is still acceptable.\n */\nAugmentedVirtuality.DEFAULT_MAXIMUM_UPDATES_PER_SECOND = 10.0;\n\n/**\n * The minimum height that the viewer is allowed to hover at.\n */\nAugmentedVirtuality.MINIMUM_HOVER_HEIGHT = 20.0;\n\n/* These are the heights that we can toggle through (in meters - above the surface height).\n */\nAugmentedVirtuality.PRESET_HEIGHTS = [1000, 250, 20];\n\n/**\n * Toggles whether the AugmentedVirutuality mode is enabled or disabled.\n */\nAugmentedVirtuality.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled;\n};\n\n/**\n * Toggles whether manual alignement is enabled or disabled.\n */\nAugmentedVirtuality.prototype.toggleManualAlignment = function () {\n    this.manualAlignment = !this.manualAlignment;\n};\n\n/**\n * Resets the alignment so that the alignement matches the devices absolute alignment.\n */\nAugmentedVirtuality.prototype.resetAlignment = function () {\n    this._orientationUpdated = true;\n    this._realignAlpha = 0;\n    this._realignHeading = 0;\n};\n\n/**\n * Toggles the viewer between a range of predefined heights, setting the cameras orientation so that it matches the\n * correct orientation.\n */\nAugmentedVirtuality.prototype.toggleHoverHeight = function () {\n    this._hoverLevel = (this._hoverLevel + 1) % AugmentedVirtuality.PRESET_HEIGHTS.length;\n\n    this.hover(AugmentedVirtuality.PRESET_HEIGHTS[this._hoverLevel]);\n};\n\n/**\n * Moves the viewer to a specified height, setting the orientation so that it matches the correct Augmented Virtuality\n * orientation.\n *\n * @param {Float} height The height in Meters above the globe surface. Note: If height is below\n *                       {@link AugmentedVirtuality.MINIMUM_HOVER_HEIGHT} the height will be set to\n *                       {@link AugmentedVirtuality.MINIMUM_HOVER_HEIGHT} to avoid visual artifacts when the viewer\n *                       becomes to close to the surface.\n * @param {Cartographic} [position] The location to hover over. If not specified the current camera location will be used.\n * @param {Boolean} [flyTo=true] Whether to fly to the location (true) or whether to jump to the location (false).\n */\nAugmentedVirtuality.prototype.hover = function (height, position, flyTo) {\n    var that = this;\n\n    // Get access to the camera...if it is not avaliable we can't set the new height so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    if (!(0, _defined2.default)(position)) {\n        position = camera.positionCartographic.clone();\n    }\n\n    flyTo = (0, _defaultValue2.default)(flyTo, true);\n\n    // Clamp the minimum hover height (heights below this value could lead to poor visual artifacts).\n    if (height < AugmentedVirtuality.MINIMUM_HOVER_HEIGHT) {\n        height = AugmentedVirtuality.MINIMUM_HOVER_HEIGHT;\n    }\n\n    // Reset the viewer height.\n    function flyToHeight(surfaceHeight) {\n        if ((0, _defined2.default)(surfaceHeight)) {\n            height += surfaceHeight;\n        }\n\n        var newPosition = _Cartesian2.default.fromRadians(position.longitude, position.latitude, height);\n        var pose = that._getCurrentOrientation();\n        pose.destination = newPosition;\n\n        if (flyTo) {\n            camera.flyTo(pose);\n        } else {\n            camera.setView(pose);\n        }\n\n        // Needed on mobile to make sure that the render is marked as dirty so that once AV mode has been disabled for a\n        // while and then is reenabled the .setView() function still has effect (otherwise dispite the call the .setView()\n        // the view orientation does not visually update until the user manualy moves the camera position).\n        that._terria.currentViewer.notifyRepaintRequired();\n    }\n\n    // Get the ground surface height at this location and offset the height by it.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.scene) || !(0, _defined2.default)(this._terria.cesium.scene.terrainProvider) || this._terria.cesium.scene.terrainProvider instanceof _EllipsoidTerrainProvider2.default) {\n        // If we can't get access to the terrain provider or we can get access to the terrain provider and the provider is just the Ellipsoid then use the height of 0.\n        flyToHeight(0);\n    } else {\n        var terrainProvider = this._terria.cesium.scene.terrainProvider;\n        (0, _sampleTerrainMostDetailed2.default)(terrainProvider, [position]).then(function (updatedPosition) {\n            flyToHeight(updatedPosition[0].height);\n        });\n    }\n};\n\n/**\n * Moves the viewer to a specified location while maintaining the current height and the correct Augmented Virtuality\n * orientation.\n *\n * @param {Cartographic} position The location to hover move to.\n * @param {Float} [maximumHeight] The maximum height (in meters) to cap the current camera height to (if this value is\n *                                specified and the viewer is above this height the camera will be restricted to this height).\n * @param {Boolean} [flyTo] Whether to fly to the location (true) or whether to jump to the location (false).\n *\n * When the manual alignment is enabled this function has no effect.\n */\nAugmentedVirtuality.prototype.moveTo = function (position, maximumHeight, flyTo) {\n    var that = this;\n\n    // If we are in manual alignment mode we don't allow the viewer to move (since this would create a jaring UX for most use cases).\n    if (this._manualAlignment) {\n        return;\n    }\n\n    // Get access to the camera...if it is not avaliable we can't get the current height (or set the new location) so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    var cameraPosition = camera.positionCartographic.clone();\n    var viewerHeight = cameraPosition.height;\n\n    // Reset the viewer height.\n    function moveToLocation(surfaceHeight) {\n        if (!(0, _defined2.default)(surfaceHeight)) {\n            surfaceHeight = 0;\n        }\n\n        var hoverHeight = viewerHeight - surfaceHeight;\n        if ((0, _defined2.default)(maximumHeight) && hoverHeight > maximumHeight) {\n\n            hoverHeight = maximumHeight;\n        }\n\n        that.hover(hoverHeight, position, flyTo);\n    }\n\n    // Get the ground surface height at this location and offset the height by it.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.scene) || !(0, _defined2.default)(this._terria.cesium.scene.terrainProvider) || this._terria.cesium.scene.terrainProvider instanceof _EllipsoidTerrainProvider2.default) {\n        // If we can't get access to the terrain provider or we can get access to the terrain provider and the provider is just the Ellipsoid then use the height of 0.\n        moveToLocation(undefined);\n    } else {\n        var terrainProvider = this._terria.cesium.scene.terrainProvider;\n        (0, _sampleTerrainMostDetailed2.default)(terrainProvider, [cameraPosition]).then(function (updatedPosition) {\n            moveToLocation(updatedPosition[0].height);\n        });\n    }\n};\n\n/**\n * Whether the user is currently setting a manual alignment.\n *\n * See also {@link AugmentedVirtuality#_setManualAlignment}.\n *\n * @return {Boolean} Whether the user is currently setting a manual alignment (true) or not (false).\n * @private\n */\nAugmentedVirtuality.prototype._getManualAlignment = function () {\n    return this.enabled && this._manualAlignment;\n};\n\n/**\n * Starts / stops manual alignment.\n *\n * When manual realignment is enabled it allows the user to specify a new origin for the alignment between the devices\n * physical and virtual alignment. When manual alignment is enabled the orientation is locked, to allow the user to\n * realign a visual landmark with a physical landmark.\n *\n * Note: Manual alignment is only done for the heading axis, this is because in practice we have found that the heading\n * axis is often out as mobile devices seem to have difficulty obtaining the compass direction, but seem to perform\n * relatively well in the other axes.\n *\n * Note: Realignment is only possible when AugmentedVirtuality is enabled. If AugmentedVirtuality is disabled while\n *       manual alignment is in progress it will be cancelled.\n *\n * See also {@link AugmentedVirtuality#_getManualAlignment}.\n *\n * @param {Boolean} startEnd Whether the user is starting (true) or ending (false) the realignment.\n * @private\n */\nAugmentedVirtuality.prototype._setManualAlignment = function (startEnd) {\n    // Only allow manual alignment changes when the module is enabled.\n    if (this.enabled !== true) {\n        return;\n    }\n\n    // Sanitise the input value to a boolean.\n    if (startEnd !== true) {\n        startEnd = false;\n    }\n\n    if (startEnd === false && (0, _defined2.default)(this._terria.cesium) && (0, _defined2.default)(this._terria.cesium.viewer) && (0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        this._realignAlpha = this._alpha;\n        this._realignHeading = _Math2.default.toDegrees(this._terria.cesium.viewer.camera.heading);\n    }\n\n    if (this._manualAlignment !== startEnd) {\n        this._manualAlignment = startEnd;\n        this._startEventLoop(!this._manualAlignment);\n    }\n};\n\n/**\n * Whether the event loop is currently running.\n *\n * @return {Boolean} enable Whether to start the event loop is currently running (true) or not (false).\n * @private\n */\nAugmentedVirtuality.prototype._eventLoopRunning = function () {\n    return (0, _defined2.default)(this._eventLoopState.intervalId);\n};\n\n/**\n * Start or stop the Augmented Virutuality mode event loop. When enabled the orientation will effect the cameras\n * view and when disabled the device orientation will not effect the cameras view.\n *\n * @param {Boolean} enable Whether to start the event loop (true) or stop the event loop (false).\n * @private\n */\nAugmentedVirtuality.prototype._startEventLoop = function (enable) {\n    // Are we actually changing the state?\n    if (this._eventLoopRunning() !== enable) {\n        if (enable === true) {\n            var that = this;\n\n            this._orientationUpdated = true;\n\n            var intervalMs = 1000 / this._maximumUpdatesPerSecond;\n            var id = setInterval(function () {\n                that._updateOrientation();\n            }, intervalMs);\n            this._eventLoopState = { intervalId: id };\n        } else {\n            clearInterval(this._eventLoopState.intervalId);\n            this._eventLoopState = {};\n        }\n    }\n};\n\n/**\n * Device orientation update event callback function. Stores the updated orientation into the object state.\n *\n * @param {Object} event Contains the updated device orientation (in .alpha, .beta, .gamma).\n * @private\n */\nAugmentedVirtuality.prototype._storeOrientation = function (event) {\n    this._alpha = event.alpha;\n    this._beta = event.beta;\n    this._gamma = event.gamma;\n    this._orientationUpdated = true;\n};\n\n/**\n * This function updates the cameras orientation using the last orientation recorded and the current screen orientation.\n *\n * @private\n */\nAugmentedVirtuality.prototype._updateOrientation = function () {\n\n    // Check if the screen orientation has changed and mark the orientation updated if it has.\n    var screenOrientation = this._getCurrentScreenOrientation();\n    if (screenOrientation !== this._lastScreenOrientation) {\n        this._orientationUpdated = true;\n    }\n    this._lastScreenOrientation = screenOrientation;\n\n    // Optomise by only updating the camera view if some part of the orientation calculation has changed.\n    if (!this._orientationUpdated) {\n        // The orientation has not been updated so don't waste time changing the orientation.\n        return;\n    }\n    this._orientationUpdated = false;\n\n    // Get access to the camera...if it is not avaliable we can't set the orientation so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    camera.setView(this._getCurrentOrientation(screenOrientation));\n\n    // Needed on mobile to make sure that the render is marked as dirty so that once AV mode has been disabled for a\n    // while and then is reenabled the .setView() function still has effect (otherwise dispite the call the .setView()\n    // the view orientation does not visually update until the user manualy moves the camera position).\n    this._terria.currentViewer.notifyRepaintRequired();\n};\n\n/**\n * Gets the current orientation stored in the object state and returns the roll, pitch and heading which can be used to set the cameras orientation.\n *\n * @param {Float} screenOrientation The screen orientation in degrees. Note: This field is optional, if supplied this value will be used for the screen orientation, otherwise the screen orientation will be obtained during the execution of this function.\n * @return {Object} A object with the roll, pitch and heading stored into the orientation.\n * @private\n */\nAugmentedVirtuality.prototype._getCurrentOrientation = function (screenOrientation) {\n    var alpha = this._alpha;\n    var beta = this._beta;\n    var gamma = this._gamma;\n\n    var realignAlpha = this._realignAlpha;\n    var realignHeading = this._realignHeading;\n\n    if (!(0, _defined2.default)(screenOrientation)) {\n        screenOrientation = this._getCurrentScreenOrientation();\n    }\n\n    return this._computeTerriaOrientation(alpha, beta, gamma, screenOrientation, realignAlpha, realignHeading);\n};\n\n/**\n * Turns the orientation in the device frame of reference into an orientation suitable for specifying the Terria camera orientation.\n *\n * @param {Float} alpha The alpha value of the device orientation in degrees (this is the alpha value in the device's frame of reference).\n * @param {Float} beta  The beta  value of the device orientation in degrees (this is the beta  value in the device's frame of reference).\n * @param {Float} gamma The gamma value of the device orientation in degrees (this is the gamma value in the device's frame of reference).\n * @param {Float} screenOrientation The screen orientation in degrees.\n * @param {Float} realignAlpha   The value of the alpha   value the last time realignment was completed (supply zero if realignment is not supported).\n * @param {Float} realignHeading The value of the heading value the last time realignment was completed (supply zero if realignment is not supported).\n * @return {Object} An object with the roll, pitch and heading stored into the orientation.\n * @private\n */\nAugmentedVirtuality.prototype._computeTerriaOrientation = function (alpha, beta, gamma, screenOrientation, realignAlpha, realignHeading) {\n    // Note: The algorithmic formulation in this function is for simplicity of mathematical expression, readability,\n    //       maintainability and modification (i.e. it is easy to understand how to update or insert new offsets or features).\n    //       This is not the simplest form which clearly flows from the current formuleation and clearly simplify the\n    //       logic and operations but would increase the cost of future modifications and reduce the readability of the\n    //       expression. It is not anticipated that the current verbose implementation would have a significant impact\n    //       on performance or accuracy, but obviously there will be some impact on both and it can be simplified in\n    //       future if needed.\n\n    var rotation = _Matrix2.default.clone(_Matrix2.default.IDENTITY, rotation);\n    var rotationIncrement = void 0;\n\n    // Roll - Counteract the change in the (orientation) frame of reference when the screen is rotated and the\n    //        rotation lock is not on (the browser reorients the frame of reference to align with the new screen\n    //        orientation - where as we want it of the device relative to the world).\n    rotationIncrement = _Matrix2.default.fromRotationZ(_Math2.default.toRadians(screenOrientation));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Pitch - Align the device orientation frame with the ceasium orientation frame.\n    rotationIncrement = _Matrix2.default.fromRotationX(_Math2.default.toRadians(90));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Roll - Apply the deivce roll.\n    rotationIncrement = _Matrix2.default.fromRotationZ(_Math2.default.toRadians(gamma));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Pitch - Apply the deivce pitch.\n    rotationIncrement = _Matrix2.default.fromRotationX(_Math2.default.toRadians(-beta));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Heading - Apply the incremental deivce heading (from when start was last triggered).\n    rotationIncrement = _Matrix2.default.fromRotationY(_Math2.default.toRadians(-(alpha - realignAlpha)));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Heading - Use the offset when the orientation was last started.\n    //           Note: This is logically different from the alpha value and can only be applied here in the same way\n    //                 since Cesium camera is RPH (Heading last - most local). See Cesium camera rotation decomposition\n    //                 for more information on the Cesium camera formuleation.\n    rotationIncrement = _Matrix2.default.fromRotationY(_Math2.default.toRadians(realignHeading));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Decompose rotation matrix into roll, pitch and heading to supply to Cesium camera.\n    //\n    // Use notation:\n    //     R = Roll, P = Pitch, H = Heading\n    //     SH = Sin(Heading), CH = Cos(Heading)\n    //\n    // Ceasium camera rotation = RPH:\n    //     [ CR, -SR,   0][  1,   0,   0][ CH,   0,  SH]   [CRCH-SRSPSH, -SRCP, CRSH-SRSPCH]\n    //     [ SR,  CR,   0][  0,  CP,  SP][  0,   1,   0] = [SRCH-CRSPSH,  CRCP, SRSH+CRSPCH]\n    //     [  0,   0,   1][  0, -SP,  CP][-SH,   0,  CH]   [   -CPSH   ,   -SP,    CPCH    ]\n    //     Note: The sign difference of the Sin terms in pitch is different to the standard right handed rotation since\n    //           Cesium rotates pitch in the left handed direction. Both heading and roll are right handed rotations.\n    //\n    // Use the following notation to refer to elements in the Cesium camera rotation matrix:\n    //     [R00, R10, R20]\n    //     [R01, R11, R21]\n    //     [R02, R12, R22]\n    //\n    // Also note: Tan(X) = Sin(X) / Cos(X)\n    //\n    // Decompose matrix:\n    //    H = ATan(Tan(H)) = ATan(Sin(H)/Cos(H)) = ATan (SH / CH) = ATan(CPSH/CPCH) = ATan (-R02 / R22)\n    //    R = ATan(Tan(R)) = ATan(Sin(R)/Cos(R)) = ATan (SR / CR) = ATan(SRCP/CRCP) = ATan (-R10 / R11)\n    //    P = ATan(Tan(P)) = ATan(Sin(P)/Cos(P)) = ATan (SP / CP)\n    //                                             SP = -R12\n    //                                             Need to find CP:\n    //                                                 CP = Sqrt(CP^2)\n    //                                                    = Sqrt(CP^2*(CH^2+SH^2))              Since: (Cos@^2 + Sin@^2) = 1\n    //                                                    = Sqrt((CP^2)*(CH^2) + (CP^2)*(SH^2)) Expand\n    //                                                    = Sqrt((CPCH)^2 + (CPSH)^2)           Since: N^2*M^2 = (NM)^2\n    //                                                    = Sqrt(R22^2 + (-R02)^2)              Substitute\n    //                                                    = Sqrt(R22^2 + R02^2)                 Since: (-N)^2 = N^2\n    //  So P = ATan (-R12 / Sqrt(R22^2 + R02^2))\n\n\n    // Simplify notation for readability:\n    var r10 = rotation[_Matrix2.default.COLUMN1ROW0];\n    var r11 = rotation[_Matrix2.default.COLUMN1ROW1];\n    var r02 = rotation[_Matrix2.default.COLUMN0ROW2];\n    var r12 = rotation[_Matrix2.default.COLUMN1ROW2];\n    var r22 = rotation[_Matrix2.default.COLUMN2ROW2];\n\n    var heading = _Math2.default.toDegrees(Math.atan2(-r02, r22));\n    var roll = _Math2.default.toDegrees(Math.atan2(-r10, r11));\n    var pitch = _Math2.default.toDegrees(Math.atan2(-r12, Math.sqrt(r02 * r02 + r22 * r22)));\n\n    // Create an object with the roll, pitch and heading we just computed.\n    return {\n        orientation: {\n            roll: _Math2.default.toRadians(roll),\n            pitch: _Math2.default.toRadians(pitch),\n            heading: _Math2.default.toRadians(heading)\n        }\n    };\n};\n\n/**\n * Gets the current screen orientation.\n *\n * @return {Object} The current screen orientation in degrees.\n * @private\n */\nAugmentedVirtuality.prototype._getCurrentScreenOrientation = function () {\n    if ((0, _defined2.default)(screen.orientation) && (0, _defined2.default)(screen.orientation.angle)) {\n        return screen.orientation.angle;\n    }\n\n    if ((0, _defined2.default)(window.orientation)) {\n        return window.orientation;\n    }\n\n    return 0;\n};\n\nmodule.exports = AugmentedVirtuality;\n\n/***/ }),\n\n/***/ 808:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _react = __webpack_require__(4);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _createReactClass = __webpack_require__(8);\n\nvar _createReactClass2 = _interopRequireDefault(_createReactClass);\n\nvar _propTypes = __webpack_require__(5);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _ObserveModelMixin = __webpack_require__(11);\n\nvar _ObserveModelMixin2 = _interopRequireDefault(_ObserveModelMixin);\n\nvar _augmented_virtuality_tool = __webpack_require__(2268);\n\nvar _augmented_virtuality_tool2 = _interopRequireDefault(_augmented_virtuality_tool);\n\nvar _Icon = __webpack_require__(30);\n\nvar _Icon2 = _interopRequireDefault(_Icon);\n\nvar _ViewerMode = __webpack_require__(133);\n\nvar _ViewerMode2 = _interopRequireDefault(_ViewerMode);\n\nvar _defined = __webpack_require__(0);\n\nvar _defined2 = _interopRequireDefault(_defined);\n\nvar _AugmentedVirtuality = __webpack_require__(2269);\n\nvar _AugmentedVirtuality2 = _interopRequireDefault(_AugmentedVirtuality);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar AugmentedVirtualityTool = (0, _createReactClass2.default)({\n    displayName: 'AugmentedVirtualityTool',\n    mixins: [_ObserveModelMixin2.default],\n\n    propTypes: {\n        terria: _propTypes2.default.object.isRequired,\n        viewState: _propTypes2.default.object.isRequired,\n        experimentalWarning: _propTypes2.default.bool\n    },\n\n    getInitialState: function getInitialState() {\n        return {\n            augmentedVirtuality: new _AugmentedVirtuality2.default(this.props.terria),\n            experimentalWarningShown: false,\n            realignHelpShown: false,\n            resetRealignHelpShown: false\n        };\n    },\n    handleClickAVTool: function handleClickAVTool() {\n        // Make the AugmentedVirtuality module avaliable elsewhere.\n        this.props.terria.augmentedVirtuality = this.state.augmentedVirtuality;\n\n        if ((0, _defined2.default)(this.props.experimentalWarning) && this.props.experimentalWarning !== false && !this.state.experimentalWarningShown) {\n\n            this.setState({ experimentalWarningShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Experimental Feature: Augmented Reality',\n                message: 'Augmented Reality mode is currently in beta. ' + 'This mode is only designed for use on the latest high end mobile devices. ' + '<br /><br />WARNING: This mode can consume a lot of data, please be mindful of data usage charges from your network provider. ' + '<br /><br />The accuracy of this mode depends on the accuracy of your mobile devices internal compass.',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.toggleEnabled();\n    },\n    handleClickRealign: function handleClickRealign() {\n        if (!this.state.realignHelpShown) {\n            this.setState({ realignHelpShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Manual Alignment',\n                message: 'Align your mobile device so that it corresponds with the maps current alignment, then click the blinking compass.' + ' If no landmarks to align with are currently visible on the map, you can move the map using' + ' drag and pinch actions until a recognisable landmark is visible before aligning the device with the map.' + '<br /><div><img width=\"100%\" src=\"./build/TerriaJS/images/ar-realign-guide.gif\" /></div>' + '<br />Tip: The sun or moon are often good landmarks to align with if you are in a location you aren\\x27t familiar with (be careful not to look at the sun - it can hurt your eyes).',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.toggleManualAlignment();\n    },\n    handleClickResetRealign: function handleClickResetRealign() {\n        if (!this.state.resetRealignHelpShown) {\n            this.setState({ resetRealignHelpShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Reset Alignment',\n                message: 'Resetting to compass alignment. If the alignment doesn\\x27t match the real world try waving' + ' your device in a figure 8 motion to recalibrate device. This can be done at any time.' + '<br /> <br />Avoid locations with magnetic fields or metal objects as these may disorient the devices compass.',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.resetAlignment();\n    },\n    handleClickHover: function handleClickHover() {\n        this.state.augmentedVirtuality.toggleHoverHeight();\n    },\n    render: function render() {\n        var enabled = this.state.augmentedVirtuality.enabled;\n        var toggleImage = _Icon2.default.GLYPHS.arOff;\n        var toggleStyle = _augmented_virtuality_tool2.default.btn;\n        if (enabled) {\n            toggleImage = _Icon2.default.GLYPHS.arOn;\n            toggleStyle = _augmented_virtuality_tool2.default.btnPrimary;\n        }\n\n        var realignment = this.state.augmentedVirtuality.manualAlignment;\n        var realignmentStyle = _augmented_virtuality_tool2.default.btn;\n        if (realignment) {\n            realignmentStyle = _augmented_virtuality_tool2.default.btnBlink;\n        }\n\n        var hoverLevel = this.state.augmentedVirtuality.hoverLevel;\n        var hoverImage = _Icon2.default.GLYPHS.arHover0;\n        // Note: We use the image of the next level that we will be changing to, not the level the we are currently at.\n        switch (hoverLevel) {\n            case 0:\n                hoverImage = _Icon2.default.GLYPHS.arHover0;\n                break;\n            case 1:\n                hoverImage = _Icon2.default.GLYPHS.arHover1;\n                break;\n            case 2:\n                hoverImage = _Icon2.default.GLYPHS.arHover2;\n                break;\n        }\n\n        return this.props.terria.viewerMode !== _ViewerMode2.default.Leaflet ? _react2.default.createElement(\n            'div',\n            { className: _augmented_virtuality_tool2.default.augmentedVirtualityTool },\n            _react2.default.createElement(\n                'button',\n                { type: 'button', className: toggleStyle,\n                    title: 'augmented reality tool',\n                    onClick: this.handleClickAVTool },\n                _react2.default.createElement(_Icon2.default, { glyph: toggleImage })\n            ),\n            enabled ? [_react2.default.createElement(\n                'button',\n                { type: 'button', className: _augmented_virtuality_tool2.default.btn,\n                    title: 'toggle hover height',\n                    onClick: this.handleClickHover, key: '0'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: hoverImage })\n            ), !this.state.augmentedVirtuality.manualAlignmentSet ? _react2.default.createElement(\n                'button',\n                { type: 'button', className: realignmentStyle,\n                    title: 'toggle manual alignment',\n                    onClick: this.handleClickRealign, key: '1'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: _Icon2.default.GLYPHS.arRealign })\n            ) : null, this.state.augmentedVirtuality.manualAlignmentSet && !realignment ? _react2.default.createElement(\n                'button',\n                { type: 'button', className: _augmented_virtuality_tool2.default.btn,\n                    title: 'reset compass alignment',\n                    onClick: this.handleClickResetRealign, key: '2'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: _Icon2.default.GLYPHS.arResetAlignment })\n            ) : null] : null\n        ) : null;\n    }\n});\n\nmodule.exports = AugmentedVirtualityTool;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 2.TerriaMap.js","// removed by extract-text-webpack-plugin\nmodule.exports = {\"btn\":\"tjs-augmented_virtuality_tool__btn tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-primary\":\"tjs-augmented_virtuality_tool__btn-primary tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btnPrimary\":\"tjs-augmented_virtuality_tool__btn-primary tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-blink\":\"tjs-augmented_virtuality_tool__btn-blink tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btnBlink\":\"tjs-augmented_virtuality_tool__btn-blink tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-primary--hover\":\"tjs-augmented_virtuality_tool__btn-primary--hover\",\"btnPrimaryHover\":\"tjs-augmented_virtuality_tool__btn-primary--hover\",\"blinker\":\"tjs-augmented_virtuality_tool__blinker\",\"toolButton\":\"tjs-augmented_virtuality_tool__toolButton\",\"augmentedVirtualityTool\":\"tjs-augmented_virtuality_tool__augmentedVirtualityTool tjs-tool_button__toolButton\"};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/terriajs/lib/ReactViews/Map/Navigation/augmented_virtuality_tool.scss\n// module id = 2268\n// module chunks = 2","'use strict';\n\nvar _defined = require('terriajs-cesium/Source/Core/defined');\n\nvar _defined2 = _interopRequireDefault(_defined);\n\nvar _defaultValue = require('terriajs-cesium/Source/Core/defaultValue');\n\nvar _defaultValue2 = _interopRequireDefault(_defaultValue);\n\nvar _knockout = require('terriajs-cesium/Source/ThirdParty/knockout');\n\nvar _knockout2 = _interopRequireDefault(_knockout);\n\nvar _Math = require('terriajs-cesium/Source/Core/Math.js');\n\nvar _Math2 = _interopRequireDefault(_Math);\n\nvar _Matrix = require('terriajs-cesium/Source/Core/Matrix3.js');\n\nvar _Matrix2 = _interopRequireDefault(_Matrix);\n\nvar _Cartesian = require('terriajs-cesium/Source/Core/Cartesian3.js');\n\nvar _Cartesian2 = _interopRequireDefault(_Cartesian);\n\nvar _EllipsoidTerrainProvider = require('terriajs-cesium/Source/Core/EllipsoidTerrainProvider');\n\nvar _EllipsoidTerrainProvider2 = _interopRequireDefault(_EllipsoidTerrainProvider);\n\nvar _sampleTerrainMostDetailed = require('terriajs-cesium/Source/Core/sampleTerrainMostDetailed');\n\nvar _sampleTerrainMostDetailed2 = _interopRequireDefault(_sampleTerrainMostDetailed);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Manages state for Augmented Virtuality mode.\n *\n * This mode uses the devices orientation sensors to change the viewers viewport to match the change in orientation.\n *\n * Term Augmented Virtuality:\n * \"The use of real-world sensor information (e.g., gyroscopes) to control a virtual environment is an additional form\n * of augmented virtuality, in which external inputs provide context for the virtual view.\"\n * {@link https://en.wikipedia.org/wiki/Mixed_reality}\n *\n * @alias AugmentedVirtuality\n * @constructor\n */\nvar AugmentedVirtuality = function AugmentedVirtuality(terria) {\n    var that = this;\n\n    this._terria = terria;\n\n    // Note: We create a persistant object and define a transient property, since knockout needs a persistant variable\n    //       to track, but for state we want a 'maybe' intervalId.\n    this._eventLoopState = {};\n\n    this._manualAlignment = false;\n\n    this._maximumUpdatesPerSecond = AugmentedVirtuality.DEFAULT_MAXIMUM_UPDATES_PER_SECOND;\n\n    this._orientationUpdated = false;\n    this._alpha = 0;\n    this._beta = 0;\n    this._gamma = 0;\n    this._realignAlpha = 0;\n    this._realignHeading = 0;\n\n    // Set the default height to be the last height so that when we first toggle (and increment) we cycle and go to the first height.\n    this._hoverLevel = AugmentedVirtuality.PRESET_HEIGHTS.length - 1;\n\n    // Always run the device orientation event, this way as soon as we enable we know where we are and set the\n    // orientation rather then having to wait for the next update.\n    // The following is disabled because chrome does not currently support deviceorientationabsolute correctly:\n    // if ('ondeviceorientationabsolute' in window)\n    // {\n    //     window.addEventListener('deviceorientationabsolute', function(event) {that._orientationUpdate(event);} );\n    // }\n    // else\n    if ('ondeviceorientation' in window) {\n        window.addEventListener('deviceorientation', function (event) {\n            that._storeOrientation(event);\n        });\n    }\n\n    // Make the variables used by the object properties knockout observable so that changes in the state notify the UI\n    // and cause a UI update. Note: These are all of the variables used just by the getters (not the setters), since\n    // these unqiquely define what the current state is and are the only things that can effect/cause the state to change\n    // (note: _eventLoopState is hidden behind ._eventLoopRunning() ).\n    _knockout2.default.track(this, ['_eventLoopState', '_manualAlignment', '_maximumUpdatesPerSecond', '_realignAlpha', '_realignHeading', '_hoverLevel']);\n\n    // Note: The following properties are defined as knockout properties so that they can be used to trigger updates on the UI.\n    /**\n     * Gets or sets whether Augmented Virtuality mode is currently enabled (true) or not (false).\n     *\n     * Note: If {@link AugmentedVirtuality#manualAlignment} is enabled and the state is changed it will be disabled.\n     *\n     * @memberOf AugmentedVirtuality.prototype\n     * @member {Boolean} enabled\n     */\n    _knockout2.default.defineProperty(this, 'enabled', {\n        get: function get() {\n            return this._eventLoopRunning() || this._manualAlignment;\n        },\n        set: function set(enable) {\n            if (enable !== true) {\n                enable = false;\n\n                this.resetAlignment();\n            }\n\n            if (enable !== this.enabled) {\n                // If we are changing the enabled state then disable manual alignment.\n                // We only do this if we are changing the enabled state so that the client can repeatedly call the\n                // setting without having any effect if they aren't changing the enabled state, but so that every time\n                // that the state is changed that the manual alignment is turned back off initally.\n                this._manualAlignment = false;\n\n                this._startEventLoop(enable);\n            }\n        }\n    });\n\n    /**\n     * Gets or sets whether manual realignment mode is currently enabled (true) or not (false).\n     *\n     * @memberOf AugmentedVirtuality.prototype\n     * @member {Boolean} manualAlignment\n     */\n    _knockout2.default.defineProperty(this, 'manualAlignment', {\n        get: function get() {\n            return this._getManualAlignment();\n        },\n        set: function set(startEnd) {\n            this._setManualAlignment(startEnd);\n        }\n    });\n\n    /**\n     * Gets whether a manual realignment has been specified (true) or not (false).\n     *\n     * @memberOf AugmentedVirtuality.prototype\n     * @member {Boolean} manualAlignmentSet\n     */\n    _knockout2.default.defineProperty(this, 'manualAlignmentSet', {\n        get: function get() {\n            return this._realignAlpha !== 0.0 || this._realignHeading !== 0.0;\n        }\n    });\n\n    /**\n     * Gets the index of the current hover level.\n     *\n     * Use <code>AugmentedVirtuality.PRESET_HEIGHTS.length</code> to find the total avaliable levels.\n     *\n     * @memberOf AugmentedVirtuality.prototype\n     * @member {int} hoverLevel\n     */\n    _knockout2.default.defineProperty(this, 'hoverLevel', {\n        get: function get() {\n            return this._hoverLevel;\n        }\n    });\n\n    /**\n     * Gets or sets the the maximum number of times that the camera orientation will be updated per second. This is\n     * the number of camera orientation updates per seconds is capped to (explicitly the number of times the\n     * orientation is updated per second might be less but it won't be more then this number). We want the number of\n     * times that the orientation is updated capped so that we don't consume to much battery life updating to\n     * frequently, but responsiveness is still acceptable.\n     *\n     * @memberOf AugmentedVirtuality.prototype\n     * @member {Float} maximumUpdatesPerSecond\n     */\n    _knockout2.default.defineProperty(this, 'maximumUpdatesPerSecond', {\n        get: function get() {\n            return this._maximumUpdatesPerSecond;\n        },\n        set: function set(maximumUpdatesPerSecond) {\n            this._maximumUpdatesPerSecond = maximumUpdatesPerSecond;\n\n            // If we are currently enabled reset to update the timing interval used.\n            if (this._eventLoopRunning()) {\n                this._startEventLoop(false);\n                this._startEventLoop(true);\n            }\n        }\n    });\n\n    this.enabled = false;\n};\n\n/**\n * Gets the the maximum number of times that the camera orientation will be updated per second by default. This is the\n * number of camera orientation updates per seconds is capped to by default (explicitly the number of times the\n * orientation is updated per second might be less but it won't be more then this number). We want the number of times\n * that the orientation is updated capped so that we don't consume to much battery life updating to frequently, but\n * responsiveness is still acceptable.\n */\nAugmentedVirtuality.DEFAULT_MAXIMUM_UPDATES_PER_SECOND = 10.0;\n\n/**\n * The minimum height that the viewer is allowed to hover at.\n */\nAugmentedVirtuality.MINIMUM_HOVER_HEIGHT = 20.0;\n\n/* These are the heights that we can toggle through (in meters - above the surface height).\n */\nAugmentedVirtuality.PRESET_HEIGHTS = [1000, 250, 20];\n\n/**\n * Toggles whether the AugmentedVirutuality mode is enabled or disabled.\n */\nAugmentedVirtuality.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled;\n};\n\n/**\n * Toggles whether manual alignement is enabled or disabled.\n */\nAugmentedVirtuality.prototype.toggleManualAlignment = function () {\n    this.manualAlignment = !this.manualAlignment;\n};\n\n/**\n * Resets the alignment so that the alignement matches the devices absolute alignment.\n */\nAugmentedVirtuality.prototype.resetAlignment = function () {\n    this._orientationUpdated = true;\n    this._realignAlpha = 0;\n    this._realignHeading = 0;\n};\n\n/**\n * Toggles the viewer between a range of predefined heights, setting the cameras orientation so that it matches the\n * correct orientation.\n */\nAugmentedVirtuality.prototype.toggleHoverHeight = function () {\n    this._hoverLevel = (this._hoverLevel + 1) % AugmentedVirtuality.PRESET_HEIGHTS.length;\n\n    this.hover(AugmentedVirtuality.PRESET_HEIGHTS[this._hoverLevel]);\n};\n\n/**\n * Moves the viewer to a specified height, setting the orientation so that it matches the correct Augmented Virtuality\n * orientation.\n *\n * @param {Float} height The height in Meters above the globe surface. Note: If height is below\n *                       {@link AugmentedVirtuality.MINIMUM_HOVER_HEIGHT} the height will be set to\n *                       {@link AugmentedVirtuality.MINIMUM_HOVER_HEIGHT} to avoid visual artifacts when the viewer\n *                       becomes to close to the surface.\n * @param {Cartographic} [position] The location to hover over. If not specified the current camera location will be used.\n * @param {Boolean} [flyTo=true] Whether to fly to the location (true) or whether to jump to the location (false).\n */\nAugmentedVirtuality.prototype.hover = function (height, position, flyTo) {\n    var that = this;\n\n    // Get access to the camera...if it is not avaliable we can't set the new height so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    if (!(0, _defined2.default)(position)) {\n        position = camera.positionCartographic.clone();\n    }\n\n    flyTo = (0, _defaultValue2.default)(flyTo, true);\n\n    // Clamp the minimum hover height (heights below this value could lead to poor visual artifacts).\n    if (height < AugmentedVirtuality.MINIMUM_HOVER_HEIGHT) {\n        height = AugmentedVirtuality.MINIMUM_HOVER_HEIGHT;\n    }\n\n    // Reset the viewer height.\n    function flyToHeight(surfaceHeight) {\n        if ((0, _defined2.default)(surfaceHeight)) {\n            height += surfaceHeight;\n        }\n\n        var newPosition = _Cartesian2.default.fromRadians(position.longitude, position.latitude, height);\n        var pose = that._getCurrentOrientation();\n        pose.destination = newPosition;\n\n        if (flyTo) {\n            camera.flyTo(pose);\n        } else {\n            camera.setView(pose);\n        }\n\n        // Needed on mobile to make sure that the render is marked as dirty so that once AV mode has been disabled for a\n        // while and then is reenabled the .setView() function still has effect (otherwise dispite the call the .setView()\n        // the view orientation does not visually update until the user manualy moves the camera position).\n        that._terria.currentViewer.notifyRepaintRequired();\n    }\n\n    // Get the ground surface height at this location and offset the height by it.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.scene) || !(0, _defined2.default)(this._terria.cesium.scene.terrainProvider) || this._terria.cesium.scene.terrainProvider instanceof _EllipsoidTerrainProvider2.default) {\n        // If we can't get access to the terrain provider or we can get access to the terrain provider and the provider is just the Ellipsoid then use the height of 0.\n        flyToHeight(0);\n    } else {\n        var terrainProvider = this._terria.cesium.scene.terrainProvider;\n        (0, _sampleTerrainMostDetailed2.default)(terrainProvider, [position]).then(function (updatedPosition) {\n            flyToHeight(updatedPosition[0].height);\n        });\n    }\n};\n\n/**\n * Moves the viewer to a specified location while maintaining the current height and the correct Augmented Virtuality\n * orientation.\n *\n * @param {Cartographic} position The location to hover move to.\n * @param {Float} [maximumHeight] The maximum height (in meters) to cap the current camera height to (if this value is\n *                                specified and the viewer is above this height the camera will be restricted to this height).\n * @param {Boolean} [flyTo] Whether to fly to the location (true) or whether to jump to the location (false).\n *\n * When the manual alignment is enabled this function has no effect.\n */\nAugmentedVirtuality.prototype.moveTo = function (position, maximumHeight, flyTo) {\n    var that = this;\n\n    // If we are in manual alignment mode we don't allow the viewer to move (since this would create a jaring UX for most use cases).\n    if (this._manualAlignment) {\n        return;\n    }\n\n    // Get access to the camera...if it is not avaliable we can't get the current height (or set the new location) so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    var cameraPosition = camera.positionCartographic.clone();\n    var viewerHeight = cameraPosition.height;\n\n    // Reset the viewer height.\n    function moveToLocation(surfaceHeight) {\n        if (!(0, _defined2.default)(surfaceHeight)) {\n            surfaceHeight = 0;\n        }\n\n        var hoverHeight = viewerHeight - surfaceHeight;\n        if ((0, _defined2.default)(maximumHeight) && hoverHeight > maximumHeight) {\n\n            hoverHeight = maximumHeight;\n        }\n\n        that.hover(hoverHeight, position, flyTo);\n    }\n\n    // Get the ground surface height at this location and offset the height by it.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.scene) || !(0, _defined2.default)(this._terria.cesium.scene.terrainProvider) || this._terria.cesium.scene.terrainProvider instanceof _EllipsoidTerrainProvider2.default) {\n        // If we can't get access to the terrain provider or we can get access to the terrain provider and the provider is just the Ellipsoid then use the height of 0.\n        moveToLocation(undefined);\n    } else {\n        var terrainProvider = this._terria.cesium.scene.terrainProvider;\n        (0, _sampleTerrainMostDetailed2.default)(terrainProvider, [cameraPosition]).then(function (updatedPosition) {\n            moveToLocation(updatedPosition[0].height);\n        });\n    }\n};\n\n/**\n * Whether the user is currently setting a manual alignment.\n *\n * See also {@link AugmentedVirtuality#_setManualAlignment}.\n *\n * @return {Boolean} Whether the user is currently setting a manual alignment (true) or not (false).\n * @private\n */\nAugmentedVirtuality.prototype._getManualAlignment = function () {\n    return this.enabled && this._manualAlignment;\n};\n\n/**\n * Starts / stops manual alignment.\n *\n * When manual realignment is enabled it allows the user to specify a new origin for the alignment between the devices\n * physical and virtual alignment. When manual alignment is enabled the orientation is locked, to allow the user to\n * realign a visual landmark with a physical landmark.\n *\n * Note: Manual alignment is only done for the heading axis, this is because in practice we have found that the heading\n * axis is often out as mobile devices seem to have difficulty obtaining the compass direction, but seem to perform\n * relatively well in the other axes.\n *\n * Note: Realignment is only possible when AugmentedVirtuality is enabled. If AugmentedVirtuality is disabled while\n *       manual alignment is in progress it will be cancelled.\n *\n * See also {@link AugmentedVirtuality#_getManualAlignment}.\n *\n * @param {Boolean} startEnd Whether the user is starting (true) or ending (false) the realignment.\n * @private\n */\nAugmentedVirtuality.prototype._setManualAlignment = function (startEnd) {\n    // Only allow manual alignment changes when the module is enabled.\n    if (this.enabled !== true) {\n        return;\n    }\n\n    // Sanitise the input value to a boolean.\n    if (startEnd !== true) {\n        startEnd = false;\n    }\n\n    if (startEnd === false && (0, _defined2.default)(this._terria.cesium) && (0, _defined2.default)(this._terria.cesium.viewer) && (0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        this._realignAlpha = this._alpha;\n        this._realignHeading = _Math2.default.toDegrees(this._terria.cesium.viewer.camera.heading);\n    }\n\n    if (this._manualAlignment !== startEnd) {\n        this._manualAlignment = startEnd;\n        this._startEventLoop(!this._manualAlignment);\n    }\n};\n\n/**\n * Whether the event loop is currently running.\n *\n * @return {Boolean} enable Whether to start the event loop is currently running (true) or not (false).\n * @private\n */\nAugmentedVirtuality.prototype._eventLoopRunning = function () {\n    return (0, _defined2.default)(this._eventLoopState.intervalId);\n};\n\n/**\n * Start or stop the Augmented Virutuality mode event loop. When enabled the orientation will effect the cameras\n * view and when disabled the device orientation will not effect the cameras view.\n *\n * @param {Boolean} enable Whether to start the event loop (true) or stop the event loop (false).\n * @private\n */\nAugmentedVirtuality.prototype._startEventLoop = function (enable) {\n    // Are we actually changing the state?\n    if (this._eventLoopRunning() !== enable) {\n        if (enable === true) {\n            var that = this;\n\n            this._orientationUpdated = true;\n\n            var intervalMs = 1000 / this._maximumUpdatesPerSecond;\n            var id = setInterval(function () {\n                that._updateOrientation();\n            }, intervalMs);\n            this._eventLoopState = { intervalId: id };\n        } else {\n            clearInterval(this._eventLoopState.intervalId);\n            this._eventLoopState = {};\n        }\n    }\n};\n\n/**\n * Device orientation update event callback function. Stores the updated orientation into the object state.\n *\n * @param {Object} event Contains the updated device orientation (in .alpha, .beta, .gamma).\n * @private\n */\nAugmentedVirtuality.prototype._storeOrientation = function (event) {\n    this._alpha = event.alpha;\n    this._beta = event.beta;\n    this._gamma = event.gamma;\n    this._orientationUpdated = true;\n};\n\n/**\n * This function updates the cameras orientation using the last orientation recorded and the current screen orientation.\n *\n * @private\n */\nAugmentedVirtuality.prototype._updateOrientation = function () {\n\n    // Check if the screen orientation has changed and mark the orientation updated if it has.\n    var screenOrientation = this._getCurrentScreenOrientation();\n    if (screenOrientation !== this._lastScreenOrientation) {\n        this._orientationUpdated = true;\n    }\n    this._lastScreenOrientation = screenOrientation;\n\n    // Optomise by only updating the camera view if some part of the orientation calculation has changed.\n    if (!this._orientationUpdated) {\n        // The orientation has not been updated so don't waste time changing the orientation.\n        return;\n    }\n    this._orientationUpdated = false;\n\n    // Get access to the camera...if it is not avaliable we can't set the orientation so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    camera.setView(this._getCurrentOrientation(screenOrientation));\n\n    // Needed on mobile to make sure that the render is marked as dirty so that once AV mode has been disabled for a\n    // while and then is reenabled the .setView() function still has effect (otherwise dispite the call the .setView()\n    // the view orientation does not visually update until the user manualy moves the camera position).\n    this._terria.currentViewer.notifyRepaintRequired();\n};\n\n/**\n * Gets the current orientation stored in the object state and returns the roll, pitch and heading which can be used to set the cameras orientation.\n *\n * @param {Float} screenOrientation The screen orientation in degrees. Note: This field is optional, if supplied this value will be used for the screen orientation, otherwise the screen orientation will be obtained during the execution of this function.\n * @return {Object} A object with the roll, pitch and heading stored into the orientation.\n * @private\n */\nAugmentedVirtuality.prototype._getCurrentOrientation = function (screenOrientation) {\n    var alpha = this._alpha;\n    var beta = this._beta;\n    var gamma = this._gamma;\n\n    var realignAlpha = this._realignAlpha;\n    var realignHeading = this._realignHeading;\n\n    if (!(0, _defined2.default)(screenOrientation)) {\n        screenOrientation = this._getCurrentScreenOrientation();\n    }\n\n    return this._computeTerriaOrientation(alpha, beta, gamma, screenOrientation, realignAlpha, realignHeading);\n};\n\n/**\n * Turns the orientation in the device frame of reference into an orientation suitable for specifying the Terria camera orientation.\n *\n * @param {Float} alpha The alpha value of the device orientation in degrees (this is the alpha value in the device's frame of reference).\n * @param {Float} beta  The beta  value of the device orientation in degrees (this is the beta  value in the device's frame of reference).\n * @param {Float} gamma The gamma value of the device orientation in degrees (this is the gamma value in the device's frame of reference).\n * @param {Float} screenOrientation The screen orientation in degrees.\n * @param {Float} realignAlpha   The value of the alpha   value the last time realignment was completed (supply zero if realignment is not supported).\n * @param {Float} realignHeading The value of the heading value the last time realignment was completed (supply zero if realignment is not supported).\n * @return {Object} An object with the roll, pitch and heading stored into the orientation.\n * @private\n */\nAugmentedVirtuality.prototype._computeTerriaOrientation = function (alpha, beta, gamma, screenOrientation, realignAlpha, realignHeading) {\n    // Note: The algorithmic formulation in this function is for simplicity of mathematical expression, readability,\n    //       maintainability and modification (i.e. it is easy to understand how to update or insert new offsets or features).\n    //       This is not the simplest form which clearly flows from the current formuleation and clearly simplify the\n    //       logic and operations but would increase the cost of future modifications and reduce the readability of the\n    //       expression. It is not anticipated that the current verbose implementation would have a significant impact\n    //       on performance or accuracy, but obviously there will be some impact on both and it can be simplified in\n    //       future if needed.\n\n    var rotation = _Matrix2.default.clone(_Matrix2.default.IDENTITY, rotation);\n    var rotationIncrement = void 0;\n\n    // Roll - Counteract the change in the (orientation) frame of reference when the screen is rotated and the\n    //        rotation lock is not on (the browser reorients the frame of reference to align with the new screen\n    //        orientation - where as we want it of the device relative to the world).\n    rotationIncrement = _Matrix2.default.fromRotationZ(_Math2.default.toRadians(screenOrientation));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Pitch - Align the device orientation frame with the ceasium orientation frame.\n    rotationIncrement = _Matrix2.default.fromRotationX(_Math2.default.toRadians(90));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Roll - Apply the deivce roll.\n    rotationIncrement = _Matrix2.default.fromRotationZ(_Math2.default.toRadians(gamma));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Pitch - Apply the deivce pitch.\n    rotationIncrement = _Matrix2.default.fromRotationX(_Math2.default.toRadians(-beta));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Heading - Apply the incremental deivce heading (from when start was last triggered).\n    rotationIncrement = _Matrix2.default.fromRotationY(_Math2.default.toRadians(-(alpha - realignAlpha)));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Heading - Use the offset when the orientation was last started.\n    //           Note: This is logically different from the alpha value and can only be applied here in the same way\n    //                 since Cesium camera is RPH (Heading last - most local). See Cesium camera rotation decomposition\n    //                 for more information on the Cesium camera formuleation.\n    rotationIncrement = _Matrix2.default.fromRotationY(_Math2.default.toRadians(realignHeading));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Decompose rotation matrix into roll, pitch and heading to supply to Cesium camera.\n    //\n    // Use notation:\n    //     R = Roll, P = Pitch, H = Heading\n    //     SH = Sin(Heading), CH = Cos(Heading)\n    //\n    // Ceasium camera rotation = RPH:\n    //     [ CR, -SR,   0][  1,   0,   0][ CH,   0,  SH]   [CRCH-SRSPSH, -SRCP, CRSH-SRSPCH]\n    //     [ SR,  CR,   0][  0,  CP,  SP][  0,   1,   0] = [SRCH-CRSPSH,  CRCP, SRSH+CRSPCH]\n    //     [  0,   0,   1][  0, -SP,  CP][-SH,   0,  CH]   [   -CPSH   ,   -SP,    CPCH    ]\n    //     Note: The sign difference of the Sin terms in pitch is different to the standard right handed rotation since\n    //           Cesium rotates pitch in the left handed direction. Both heading and roll are right handed rotations.\n    //\n    // Use the following notation to refer to elements in the Cesium camera rotation matrix:\n    //     [R00, R10, R20]\n    //     [R01, R11, R21]\n    //     [R02, R12, R22]\n    //\n    // Also note: Tan(X) = Sin(X) / Cos(X)\n    //\n    // Decompose matrix:\n    //    H = ATan(Tan(H)) = ATan(Sin(H)/Cos(H)) = ATan (SH / CH) = ATan(CPSH/CPCH) = ATan (-R02 / R22)\n    //    R = ATan(Tan(R)) = ATan(Sin(R)/Cos(R)) = ATan (SR / CR) = ATan(SRCP/CRCP) = ATan (-R10 / R11)\n    //    P = ATan(Tan(P)) = ATan(Sin(P)/Cos(P)) = ATan (SP / CP)\n    //                                             SP = -R12\n    //                                             Need to find CP:\n    //                                                 CP = Sqrt(CP^2)\n    //                                                    = Sqrt(CP^2*(CH^2+SH^2))              Since: (Cos@^2 + Sin@^2) = 1\n    //                                                    = Sqrt((CP^2)*(CH^2) + (CP^2)*(SH^2)) Expand\n    //                                                    = Sqrt((CPCH)^2 + (CPSH)^2)           Since: N^2*M^2 = (NM)^2\n    //                                                    = Sqrt(R22^2 + (-R02)^2)              Substitute\n    //                                                    = Sqrt(R22^2 + R02^2)                 Since: (-N)^2 = N^2\n    //  So P = ATan (-R12 / Sqrt(R22^2 + R02^2))\n\n\n    // Simplify notation for readability:\n    var r10 = rotation[_Matrix2.default.COLUMN1ROW0];\n    var r11 = rotation[_Matrix2.default.COLUMN1ROW1];\n    var r02 = rotation[_Matrix2.default.COLUMN0ROW2];\n    var r12 = rotation[_Matrix2.default.COLUMN1ROW2];\n    var r22 = rotation[_Matrix2.default.COLUMN2ROW2];\n\n    var heading = _Math2.default.toDegrees(Math.atan2(-r02, r22));\n    var roll = _Math2.default.toDegrees(Math.atan2(-r10, r11));\n    var pitch = _Math2.default.toDegrees(Math.atan2(-r12, Math.sqrt(r02 * r02 + r22 * r22)));\n\n    // Create an object with the roll, pitch and heading we just computed.\n    return {\n        orientation: {\n            roll: _Math2.default.toRadians(roll),\n            pitch: _Math2.default.toRadians(pitch),\n            heading: _Math2.default.toRadians(heading)\n        }\n    };\n};\n\n/**\n * Gets the current screen orientation.\n *\n * @return {Object} The current screen orientation in degrees.\n * @private\n */\nAugmentedVirtuality.prototype._getCurrentScreenOrientation = function () {\n    if ((0, _defined2.default)(screen.orientation) && (0, _defined2.default)(screen.orientation.angle)) {\n        return screen.orientation.angle;\n    }\n\n    if ((0, _defined2.default)(window.orientation)) {\n        return window.orientation;\n    }\n\n    return 0;\n};\n\nmodule.exports = AugmentedVirtuality;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/terriajs/lib/Models/AugmentedVirtuality.js\n// module id = 2269\n// module chunks = 2","'use strict';\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _createReactClass = require('create-react-class');\n\nvar _createReactClass2 = _interopRequireDefault(_createReactClass);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _ObserveModelMixin = require('../../ObserveModelMixin');\n\nvar _ObserveModelMixin2 = _interopRequireDefault(_ObserveModelMixin);\n\nvar _augmented_virtuality_tool = require('./augmented_virtuality_tool.scss');\n\nvar _augmented_virtuality_tool2 = _interopRequireDefault(_augmented_virtuality_tool);\n\nvar _Icon = require('../../Icon');\n\nvar _Icon2 = _interopRequireDefault(_Icon);\n\nvar _ViewerMode = require('../../../Models/ViewerMode');\n\nvar _ViewerMode2 = _interopRequireDefault(_ViewerMode);\n\nvar _defined = require('terriajs-cesium/Source/Core/defined');\n\nvar _defined2 = _interopRequireDefault(_defined);\n\nvar _AugmentedVirtuality = require('../../../Models/AugmentedVirtuality');\n\nvar _AugmentedVirtuality2 = _interopRequireDefault(_AugmentedVirtuality);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar AugmentedVirtualityTool = (0, _createReactClass2.default)({\n    displayName: 'AugmentedVirtualityTool',\n    mixins: [_ObserveModelMixin2.default],\n\n    propTypes: {\n        terria: _propTypes2.default.object.isRequired,\n        viewState: _propTypes2.default.object.isRequired,\n        experimentalWarning: _propTypes2.default.bool\n    },\n\n    getInitialState: function getInitialState() {\n        return {\n            augmentedVirtuality: new _AugmentedVirtuality2.default(this.props.terria),\n            experimentalWarningShown: false,\n            realignHelpShown: false,\n            resetRealignHelpShown: false\n        };\n    },\n    handleClickAVTool: function handleClickAVTool() {\n        // Make the AugmentedVirtuality module avaliable elsewhere.\n        this.props.terria.augmentedVirtuality = this.state.augmentedVirtuality;\n\n        if ((0, _defined2.default)(this.props.experimentalWarning) && this.props.experimentalWarning !== false && !this.state.experimentalWarningShown) {\n\n            this.setState({ experimentalWarningShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Experimental Feature: Augmented Reality',\n                message: 'Augmented Reality mode is currently in beta. ' + 'This mode is only designed for use on the latest high end mobile devices. ' + '<br /><br />WARNING: This mode can consume a lot of data, please be mindful of data usage charges from your network provider. ' + '<br /><br />The accuracy of this mode depends on the accuracy of your mobile devices internal compass.',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.toggleEnabled();\n    },\n    handleClickRealign: function handleClickRealign() {\n        if (!this.state.realignHelpShown) {\n            this.setState({ realignHelpShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Manual Alignment',\n                message: 'Align your mobile device so that it corresponds with the maps current alignment, then click the blinking compass.' + ' If no landmarks to align with are currently visible on the map, you can move the map using' + ' drag and pinch actions until a recognisable landmark is visible before aligning the device with the map.' + '<br /><div><img width=\"100%\" src=\"./build/TerriaJS/images/ar-realign-guide.gif\" /></div>' + '<br />Tip: The sun or moon are often good landmarks to align with if you are in a location you aren\\x27t familiar with (be careful not to look at the sun - it can hurt your eyes).',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.toggleManualAlignment();\n    },\n    handleClickResetRealign: function handleClickResetRealign() {\n        if (!this.state.resetRealignHelpShown) {\n            this.setState({ resetRealignHelpShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Reset Alignment',\n                message: 'Resetting to compass alignment. If the alignment doesn\\x27t match the real world try waving' + ' your device in a figure 8 motion to recalibrate device. This can be done at any time.' + '<br /> <br />Avoid locations with magnetic fields or metal objects as these may disorient the devices compass.',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.resetAlignment();\n    },\n    handleClickHover: function handleClickHover() {\n        this.state.augmentedVirtuality.toggleHoverHeight();\n    },\n    render: function render() {\n        var enabled = this.state.augmentedVirtuality.enabled;\n        var toggleImage = _Icon2.default.GLYPHS.arOff;\n        var toggleStyle = _augmented_virtuality_tool2.default.btn;\n        if (enabled) {\n            toggleImage = _Icon2.default.GLYPHS.arOn;\n            toggleStyle = _augmented_virtuality_tool2.default.btnPrimary;\n        }\n\n        var realignment = this.state.augmentedVirtuality.manualAlignment;\n        var realignmentStyle = _augmented_virtuality_tool2.default.btn;\n        if (realignment) {\n            realignmentStyle = _augmented_virtuality_tool2.default.btnBlink;\n        }\n\n        var hoverLevel = this.state.augmentedVirtuality.hoverLevel;\n        var hoverImage = _Icon2.default.GLYPHS.arHover0;\n        // Note: We use the image of the next level that we will be changing to, not the level the we are currently at.\n        switch (hoverLevel) {\n            case 0:\n                hoverImage = _Icon2.default.GLYPHS.arHover0;\n                break;\n            case 1:\n                hoverImage = _Icon2.default.GLYPHS.arHover1;\n                break;\n            case 2:\n                hoverImage = _Icon2.default.GLYPHS.arHover2;\n                break;\n        }\n\n        return this.props.terria.viewerMode !== _ViewerMode2.default.Leaflet ? _react2.default.createElement(\n            'div',\n            { className: _augmented_virtuality_tool2.default.augmentedVirtualityTool },\n            _react2.default.createElement(\n                'button',\n                { type: 'button', className: toggleStyle,\n                    title: 'augmented reality tool',\n                    onClick: this.handleClickAVTool },\n                _react2.default.createElement(_Icon2.default, { glyph: toggleImage })\n            ),\n            enabled ? [_react2.default.createElement(\n                'button',\n                { type: 'button', className: _augmented_virtuality_tool2.default.btn,\n                    title: 'toggle hover height',\n                    onClick: this.handleClickHover, key: '0'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: hoverImage })\n            ), !this.state.augmentedVirtuality.manualAlignmentSet ? _react2.default.createElement(\n                'button',\n                { type: 'button', className: realignmentStyle,\n                    title: 'toggle manual alignment',\n                    onClick: this.handleClickRealign, key: '1'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: _Icon2.default.GLYPHS.arRealign })\n            ) : null, this.state.augmentedVirtuality.manualAlignmentSet && !realignment ? _react2.default.createElement(\n                'button',\n                { type: 'button', className: _augmented_virtuality_tool2.default.btn,\n                    title: 'reset compass alignment',\n                    onClick: this.handleClickResetRealign, key: '2'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: _Icon2.default.GLYPHS.arResetAlignment })\n            ) : null] : null\n        ) : null;\n    }\n});\n\nmodule.exports = AugmentedVirtualityTool;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/terriajs/lib/ReactViews/Map/Navigation/AugmentedVirtualityTool.jsx\n// module id = 808\n// module chunks = 2"],"sourceRoot":""}